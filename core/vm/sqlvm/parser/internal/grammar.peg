{
package internal

import (
	"github.com/dexon-foundation/dexon/core/vm/sqlvm/ast"
	se "github.com/dexon-foundation/dexon/core/vm/sqlvm/errors"
)
}

S
	<- _ x:Stmt? _ xs:( ';' _ s:Stmt? _ { return s, nil } )* EOF
{
	nodeSlice := prepend(x, assertSlice(xs))
	stmtSlice := make([]ast.StmtNode, len(nodeSlice))
	for idx := range nodeSlice {
		if nodeSlice[idx] != nil {
			stmtSlice[idx] = nodeSlice[idx].(ast.StmtNode)
		} else {
			stmtSlice[idx] = nil
		}
	}
	return stmtSlice, nil
}

/* Statements */
Stmt
	= SelectStmt
	/ UpdateStmt
	/ DeleteStmt
	/ InsertStmt
	/ CreateTableStmt
	/ CreateIndexStmt

SelectStmt
	= v:SelectToken
	_ f:SelectColumn fs:( _ SeparatorToken _ s:SelectColumn { return s, nil } )*
	table:( _ FromToken _ i:Identifier { return i, nil } )?
	where:( _ w:WhereClause { return w, nil } )?
	group:( _ g:GroupByClause { return g, nil } )?
	order:( _ or:OrderByClause { return or, nil } )?
	limit:( _ l:LimitClause { return l, nil } )?
	offset:( _ of:OffsetClause { return of, nil } )?
{
	node := &ast.SelectStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(v.([]byte))
	columnSlice := assertSlice(fs)
	node.Column = make([]ast.ExprWithAnyNode, len(columnSlice)+1)
	node.Column[0] = f.(ast.ExprWithAnyNode)
	for idx := range columnSlice {
		node.Column[idx+1] = columnSlice[idx].(ast.ExprWithAnyNode)
	}
	if table != nil {
		node.Table = table.(*ast.IdentifierNode)
	}
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	groupSlice := assertSlice(group)
	node.Group = make([]*ast.GroupOptionNode, len(groupSlice))
	for idx := range groupSlice {
		node.Group[idx] = groupSlice[idx].(*ast.GroupOptionNode)
	}
	orderSlice := assertSlice(order)
	node.Order = make([]*ast.OrderOptionNode, len(orderSlice))
	for idx := range orderSlice {
		node.Order[idx] = orderSlice[idx].(*ast.OrderOptionNode)
	}
	if limit != nil {
		node.Limit = limit.(*ast.LimitOptionNode)
	}
	if offset != nil {
		node.Offset = offset.(*ast.OffsetOptionNode)
	}
	return node, nil
}

SelectColumn
	= AnyLiteral
	/ Expr

UpdateStmt
	= v:UpdateToken
	_ table:Identifier
	_ SetToken
	_ a:Assignment as:( _ SeparatorToken _ s:Assignment { return s, nil } )*
	where:( _ w:WhereClause { return w, nil } )?
{
	node := &ast.UpdateStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(v.([]byte))
	node.Table = table.(*ast.IdentifierNode)
	assignSlice := prepend(a, assertSlice(as))
	node.Assignment = make([]*ast.AssignOperatorNode, len(assignSlice))
	for idx := range assignSlice {
		node.Assignment[idx] = assignSlice[idx].(*ast.AssignOperatorNode)
	}
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	return node, nil
}

DeleteStmt
	= v1:DeleteToken v2:_ v3:FromToken
	_ table:Identifier
	where:( _ w:WhereClause { return w, nil } )?
{
	node := &ast.DeleteStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(bytes.Join([][]byte{
		v1.([]byte), v2.([]byte), v3.([]byte)}, nil))
	node.Table = table.(*ast.IdentifierNode)
	if where != nil {
		node.Where = where.(*ast.WhereOptionNode)
	}
	return node, nil
}

InsertStmt
	= v1:InsertToken v2:_ v3:IntoToken
	_ table:Identifier
	_ insert:( InsertWithColumnClause / InsertWithDefaultClause )
{
	node := &ast.InsertStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(bytes.Join([][]byte{
		v1.([]byte), v2.([]byte), v3.([]byte)}, nil))
	node.Table = table.(*ast.IdentifierNode)
	switch i := insert.(ast.InsertOptionNode).(type) {
	case *ast.InsertWithColumnOptionNode:
		node.Insert = i
	case *ast.InsertWithDefaultOptionNode:
		node.Insert = i
	default:
		panic(fmt.Sprintf("unknown insert type %T", insert))
	}
	return node, nil
}

InsertValue
	= '(' _ e:MultiExprWithDefault _ ')'
{ return e, nil }

CreateTableStmt
	= v1:CreateToken v2:_ v3:TableToken
	_ table:Identifier
	_ '('
	_ column:(
		s:ColumnSchema
		ss:( _ SeparatorToken _ t:ColumnSchema { return t, nil } )*
		{ return prepend(s, assertSlice(ss)), nil }
	)?
	_ ')'
{
	node := &ast.CreateTableStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(bytes.Join([][]byte{
		v1.([]byte), v2.([]byte), v3.([]byte)}, nil))
	node.Table = table.(*ast.IdentifierNode)
	columnSlice := assertSlice(column)
	node.Column = make([]*ast.ColumnSchemaNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.ColumnSchemaNode)
	}
	return node, nil
}

ColumnSchema
	= i:Identifier
	_ t:DataType
	cs:( _ s:ColumnConstraint { return s, nil } )*
{
	node := &ast.ColumnSchemaNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Column = i.(*ast.IdentifierNode)
	node.DataType = t.(ast.TypeNode)
	constraintSlice := assertSlice(cs)
	node.Constraint = make([]ast.ColumnConstraintNode, len(constraintSlice))
	for idx, constraint := range constraintSlice {
		switch c := constraint.(ast.ColumnConstraintNode).(type) {
		case *ast.PrimaryOptionNode:
			node.Constraint[idx] = c
		case *ast.NotNullOptionNode:
			node.Constraint[idx] = c
		case *ast.UniqueOptionNode:
			node.Constraint[idx] = c
		case *ast.DefaultOptionNode:
			node.Constraint[idx] = c
		case *ast.ForeignOptionNode:
			node.Constraint[idx] = c
		case *ast.AutoIncrementOptionNode:
			node.Constraint[idx] = c
		default:
			panic(fmt.Sprintf("unknown constraint type %T", c))
		}
	}
	return node, nil
}

ColumnConstraint
	= PrimaryKeyClause
	/ NotNullClause
	/ UniqueClause
	/ DefaultClause
	/ ForeignClause
	/ AutoincrementClause

CreateIndexStmt
	= v1:CreateToken
	unique:( _ u:UniqueClause { return u, nil } )?
	v2:_ v3:IndexToken
	_ index:Identifier
	_ OnToken
	_ table:Identifier
	_ '(' _ i:Identifier is:( _ SeparatorToken _ x:Identifier { return x, nil } )* _ ')'
{
	node := &ast.CreateIndexStmtNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SetVerb(bytes.Join([][]byte{
		v1.([]byte), v2.([]byte), v3.([]byte)}, nil))
	node.Index = index.(*ast.IdentifierNode)
	node.Table = table.(*ast.IdentifierNode)
	columnSlice := assertSlice(prepend(i, assertSlice(is)))
	node.Column = make([]*ast.IdentifierNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.IdentifierNode)
	}
	if unique != nil {
		node.Unique = unique.(*ast.UniqueOptionNode)
	}
	return node, nil
}

/* Clauses */
WhereClause
	= WhereToken _ e:Expr
{
	node := &ast.WhereOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Condition = e.(ast.ExprNode)
	return node, nil
}

OrderByClause
	= OrderToken
	_ ByToken
	_ f:OrderColumn
	fs:( _ SeparatorToken _ s:OrderColumn { return s, nil } )*
{
	return prepend(f, assertSlice(fs)), nil
}

OrderColumn
	= i:Expr
	s:( _ t:( AscToken / DescToken ) { return t, nil } )?
	n:( _ NullsToken _ l:( LastToken / FirstToken ) { return l, nil } )?
{
	node := &ast.OrderOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Expr = i.(ast.ExprNode)
	node.Desc = s != nil && bytes.EqualFold(s.([]byte), []byte("DESC"))
	node.NullsFirst = n != nil && bytes.EqualFold(n.([]byte), []byte("FIRST"))
	return node, nil
}

GroupByClause
	= GroupToken
	_ ByToken
	_ f:GroupColumn
	fs:( _ SeparatorToken _ s:GroupColumn { return s, nil } )*
{
	return prepend(f, assertSlice(fs)), nil
}

GroupColumn
	= i:Expr
{
	node := &ast.GroupOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Expr = i.(ast.ExprNode)
	return node, nil
}

OffsetClause
	= OffsetToken _ i:IntegerLiteral
{
	node := &ast.OffsetOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = i.(*ast.IntegerValueNode)
	return node, nil
}

LimitClause
	= LimitToken _ i:IntegerLiteral
{
	node := &ast.LimitOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = i.(*ast.IntegerValueNode)
	return node, nil
}

InsertWithColumnClause
	= cs:( '('
			_ f:Identifier
			fs:( _ SeparatorToken _ x:Identifier { return x, nil } )*
			_ ')'
			_ { return prepend(f, assertSlice(fs)), nil }
		)?
		ValuesToken
	_ v:InsertValue
	vs:( _ SeparatorToken _ y:InsertValue { return y, nil } )*
{
	node := &ast.InsertWithColumnOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	columnSlice := assertSlice(cs)
	node.Column = make([]*ast.IdentifierNode, len(columnSlice))
	for idx := range columnSlice {
		node.Column[idx] = columnSlice[idx].(*ast.IdentifierNode)
	}
	valueSlice := assertSlice(vs)
	node.Value = make([][]ast.ExprWithDefaultNode, len(valueSlice)+1)
	node.Value[0] = v.([]ast.ExprWithDefaultNode)
	for idx := range valueSlice {
		node.Value[idx+1] = valueSlice[idx].([]ast.ExprWithDefaultNode)
	}
	return node, nil
}

InsertWithDefaultClause
	= DefaultToken _ ValuesToken
{
	node := &ast.InsertWithDefaultOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

PrimaryKeyClause
	= PrimaryToken _ KeyToken
{
	node := &ast.PrimaryOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NotNullClause
	= NotToken _ NullToken
{
	node := &ast.NotNullOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

UniqueClause
	= UniqueToken
{
	node := &ast.UniqueOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

DefaultClause
	= DefaultToken _ e:Expr
{
	node := &ast.DefaultOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Value = e.(ast.ExprNode)
	return node, nil
}

ForeignClause
	= ReferencesToken _ t:Identifier _ '(' _ f:Identifier _ ')'
{
	node := &ast.ForeignOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Table = t.(*ast.IdentifierNode)
	node.Column = f.(*ast.IdentifierNode)
	return node, nil
}

AutoincrementClause
	= AutoincrementToken
{
	node := &ast.AutoIncrementOptionNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Expressions */
Expr
	= LogicExpr

ExprWithDefault
	= &(DefaultLiteral) d:DefaultLiteral { return d, nil }
	/ Expr

LogicExpr
	= LogicExpr4

LogicExpr4
	= o:LogicExpr3
		os:( _ op:OrOperator _ s:LogicExpr3
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr3
	= o:LogicExpr2
		os:( _ op:AndOperator _ s:LogicExpr2
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr2
	= op:NotOperator _ s:LogicExpr2
	{ return opSetTarget(op.(ast.UnaryOperator), s.(ast.ExprNode)), nil }
	/ LogicExpr1

LogicExpr1
	= o:ArithmeticExpr os:( _ l:LogicExpr1Op { return l, nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

LogicExpr1Op
	= LogicExpr1In
	/ LogicExpr1Is
	/ LogicExpr1Like
	/ LogicExpr1Cmp

LogicExpr1In
	= n:( t:NotOperator _ { return t, nil } )? InToken _ '(' _ s:MultiExpr _ ')'
{
	node := &ast.InOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Right = s.([]ast.ExprNode)
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Is
	= IsToken n:( _ t:NotOperator { return t, nil } )? _ u:NullLiteral
{
	node := &ast.IsOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	opSetSubject(node, u.(*ast.NullValueNode))
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Like
	= n:( t:NotOperator _ { return t, nil } )? LikeToken _ s:Expr
	escape:( _ EscapeToken _ e:Expr { return e, nil } )?
{
	node := &ast.LikeOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	opSetSubject(node, s.(ast.ExprNode))
	if escape != nil {
		node.Escape = escape.(ast.ExprNode)
	}
	if n != nil {
		return opSetTarget(n.(ast.UnaryOperator), node), nil
	}
	return node, nil
}

LogicExpr1Cmp
	= op:CmpOperator _ s:ArithmeticExpr
{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil }

ArithmeticExpr
	= ArithmeticExpr3

ArithmeticExpr3
	= o:ArithmeticExpr2
		os:( _ op:ConcatOperator _ s:ArithmeticExpr2
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

ArithmeticExpr2
	= o:ArithmeticExpr1
		os:( _ op:AddSubOperator _ s:ArithmeticExpr1
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

ArithmeticExpr1
	= o:Operand
		os:( _ op:MulDivModOperator _ s:Operand
		{ return opSetSubject(op.(ast.BinaryOperator), s.(ast.ExprNode)), nil } )*
{ return rightJoinOperators(o.(ast.ExprNode), assertExprSlice(os)), nil }

MultiExpr
	= x:Expr xs:( _ SeparatorToken _ e:Expr { return e, nil } )*
{ return assertExprSlice(prepend(x, assertSlice(xs))), nil }

MultiExprWithDefault
	= x:ExprWithDefault xs:( _ SeparatorToken _ e:ExprWithDefault { return e, nil } )*
{
	s := assertSlice(xs)
	es := make([]ast.ExprWithDefaultNode, len(s)+1)
	es[0] = x.(ast.ExprWithDefaultNode)
	for idx := range s {
		es[idx+1] = s[idx].(ast.ExprWithDefaultNode)
	}
	return es, nil
}

Operand
	= op:UnaryOperator _ s:Operand
		{ return opSetTarget(op.(ast.UnaryOperator), s.(ast.ExprNode)), nil }
	/ '(' _ e:Expr _ ')'
		{
			node := &ast.ParenOperatorNode{}
			node.SetPosition(uint32(c.pos.offset))
			node.SetLength(uint32(len(c.text)))
			opSetTarget(node, e.(ast.ExprNode))
			return node, nil
		}
	/ &(CastToken) t:TypeCast { return t, nil }
	/ FunctionCall
	/ Value
	/ Identifier

TypeCast
	= CastToken _ '(' _ o:Expr _ AsToken _ s:DataType _ ')'
{
	node := &ast.CastOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.SourceExpr = o.(ast.ExprNode)
	node.TargetType = s.(ast.TypeNode)
	return node, nil
}

FunctionCall
	= i:Identifier _ '(' _ r:FunctionArgs? _ ')'
{
	node := &ast.FunctionOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Name = i.(*ast.IdentifierNode)
	switch a := r.(type) {
	case nil:
		node.Args = nil
	case *ast.AnySymbolNode:
		node.Args = []ast.ExprWithAnyNode{a}
	case []ast.ExprNode:
		node.Args = make([]ast.ExprWithAnyNode, len(a))
		for idx := range a {
			node.Args[idx] = a[idx]
		}
	default:
		panic(fmt.Sprintf("unexpected function arguments type %T", r))
	}
	return node, nil
}

FunctionArgs
	= AnyLiteral
	/ MultiExpr

Assignment
	= i:Identifier _ '=' _ e:ExprWithDefault
{
	node := &ast.AssignOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Column = i.(*ast.IdentifierNode)
	node.Expr = e.(ast.ExprWithDefaultNode)
	return node, nil
}

/* Operators */
UnaryOperator
	= SignOperator

SignOperator
	= Sign
{
	var node ast.UnaryOperator
	switch string(c.text) {
	case "+":
		node = &ast.PosOperatorNode{}
	case "-":
		node = &ast.NegOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown sign %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NotOperator
	= NotToken
{
	node := &ast.NotOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AndOperator
	= AndToken
{
	node := &ast.AndOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

OrOperator
	= OrToken
{
	node := &ast.OrOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

CmpOperator
	= ( "<=" / ">=" / "<>" / "!=" / [<>=] )
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "<=":
		node = &ast.LessOrEqualOperatorNode{}
	case ">=":
		node = &ast.GreaterOrEqualOperatorNode{}
	case "<>":
		node = &ast.NotEqualOperatorNode{}
	case "!=":
		node = &ast.NotEqualOperatorNode{}
	case "<":
		node = &ast.LessOperatorNode{}
	case ">":
		node = &ast.GreaterOperatorNode{}
	case "=":
		node = &ast.EqualOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown comparison operator %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

ConcatOperator
	= "||"
{
	node := &ast.ConcatOperatorNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AddSubOperator
	= [+-]
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "+":
		node = &ast.AddOperatorNode{}
	case "-":
		node = &ast.SubOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown addition or subtraction operator %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

MulDivModOperator
	= [*/%]
{
	var node ast.BinaryOperator
	switch string(c.text) {
	case "*":
		node = &ast.MulOperatorNode{}
	case "/":
		node = &ast.DivOperatorNode{}
	case "%":
		node = &ast.ModOperatorNode{}
	default:
		panic(fmt.Sprintf("unknown multiplication, division, modulo operator: %s", c.text))
	}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Types */
DataType
	= UIntType
	/ IntType
	/ UFixedType
	/ FixedType
	/ FixedBytesType
	/ DynamicBytesType
	/ BoolType
	/ AddressType

UIntType
	= "UINT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.IntTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = true
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "UIntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

IntType
	= "INT"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.IntTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = false
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "IntType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}

UFixedType
	= "UFIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = true
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "UFixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedType
	= "FIXED"i s:NonZeroLeadingInteger "X"i t:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Unsigned = false
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	fractionalDigits, code := toUint(t.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "FixedType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", t, code),
		}
		return node, err
	}
	node.Size = size
	node.FractionalDigits = fractionalDigits
	return node, nil
}

FixedBytesType
	= "BYTES"i s:NonZeroLeadingInteger !NormalIdentifierRest
{
	node := &ast.FixedBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	size, code := toUint(s.([]byte))
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "FixedBytesType",
			Message:  fmt.Sprintf("cannot parse %s as uint32: %v", s, code),
		}
		return node, err
	}
	node.Size = size
	return node, nil
}
	/ "BYTE"i !NormalIdentifierRest
{
	node := &ast.FixedBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Size = 1
	return node, nil
}

DynamicBytesType
	= "BYTES"i !NormalIdentifierRest
{
	node := &ast.DynamicBytesTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

AddressType
	= "ADDRESS"i !NormalIdentifierRest
{
	node := &ast.AddressTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

BoolType
	= ( "BOOL"i !NormalIdentifierRest
		/ "BOOLEAN"i !NormalIdentifierRest
	)
{
	node := &ast.BoolTypeNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

/* Values */
Value
	= NumberLiteral
	/ StringLiteral
	/ BoolLiteral
	/ NullLiteral

AnyLiteral
	= AnyToken
{
	node := &ast.AnySymbolNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

DefaultLiteral
	= DefaultToken
{
	node := &ast.DefaultSymbolNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

BoolLiteral
	= b:( TrueToken / FalseToken )
{
	node := &ast.BoolValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	if bytes.EqualFold(b.([]byte), []byte("TRUE")) {
		node.V = ast.BoolValueTrue
	} else {
		node.V = ast.BoolValueFalse
	}
	return node, nil
}

NullLiteral
	= NullToken
{
	node := &ast.NullValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

NumberLiteral
	= &("0" "X"i) h:Hex { return h, nil }
	/ Decimal

Sign
	= [-+]

Integer
	= [0-9]+

IntegerLiteral
	= Integer
{
	node := &ast.IntegerValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.IsAddress = false
	v, code := toDecimal(c.text)
	if code != se.ErrorCodeNil {
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "IntegerLiteral",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
		return node, err
	}
	node.V = v
	return node, nil
}

NonZeroLeadingInteger
	= ( "0" / [1-9][0-9]* )
{ return c.text, nil }

Fixnum
	= ( Integer "." Integer
		/ Integer "."
		/ Integer
		/ "." Integer
	)
{ return c.text, nil }

Decimal
	= m:Fixnum e:( "E"i Sign? Integer )?
{
	var node ast.ExprNode
	var err error
	integer := bytes.IndexByte(m.([]byte), '.') == -1 && e == nil
	v, code := toDecimal(c.text)
	if code != se.ErrorCodeNil {
		err = se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "Decimal",
			Message:  fmt.Sprintf("cannot parse %s as decimal: %v", c.text, code),
		}
	}
	if integer {
		realNode := &ast.IntegerValueNode{}
		realNode.SetPosition(uint32(c.pos.offset))
		realNode.SetLength(uint32(len(c.text)))
		realNode.IsAddress = false
		if err == nil {
			realNode.V = v
		}
		node = realNode
	} else {
		realNode := &ast.DecimalValueNode{}
		realNode.SetPosition(uint32(c.pos.offset))
		realNode.SetLength(uint32(len(c.text)))
		if err == nil {
			realNode.V = v
		}
		node = realNode
	}
	return node, err
}

Hex
	= "0x" ( [0-9A-Fa-f] )+ !NormalIdentifierRest
{
	node := hexToInteger(c.text)
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	return node, nil
}

StringLiteral
	= HexString
	/ NormalString

HexString
	= ( "HEX"i / "X"i ) "'" s:([0-9a-fA-F][0-9a-fA-F] { return c.text, nil } )* "'"
{
	node := &ast.BytesValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.V = hexToBytes(joinBytes(assertSlice(s)))
	return node, nil
}

NormalString
	= "'" s:( ( [^'\r\n\\] / "\\" . ) { return c.text, nil } )* "'"
{
	node := &ast.BytesValueNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	bs := joinBytes(assertSlice(s))
	v, bad, code := resolveString(bs)
	if code != se.ErrorCodeNil {
		msg := fmt.Sprintf("cannot resolve escape sequence '%s': %v",
			sanitizeBadEscape(bad), code)
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "NormalString",
			Message:  msg,
		}
		return node, err
	}
	node.V = v
	return node, nil
}

/* Tokens */
SelectToken
	= "SELECT"i !NormalIdentifierRest
{ return c.text, nil }

FromToken
	= "FROM"i !NormalIdentifierRest
{ return c.text, nil }

WhereToken
	= "WHERE"i !NormalIdentifierRest
{ return c.text, nil }

OrderToken
	= "ORDER"i !NormalIdentifierRest
{ return c.text, nil }

ByToken
	= "BY"i !NormalIdentifierRest
{ return c.text, nil }

GroupToken
	= "GROUP"i !NormalIdentifierRest
{ return c.text, nil }

LimitToken
	= "LIMIT"i !NormalIdentifierRest
{ return c.text, nil }

OffsetToken
	= "OFFSET"i !NormalIdentifierRest
{ return c.text, nil }

UpdateToken
	= "UPDATE"i !NormalIdentifierRest
{ return c.text, nil }

SetToken
	= "SET"i !NormalIdentifierRest
{ return c.text, nil }

DeleteToken
	= "DELETE"i !NormalIdentifierRest
{ return c.text, nil }

InsertToken
	= "INSERT"i !NormalIdentifierRest
{ return c.text, nil }

IntoToken
	= "INTO"i !NormalIdentifierRest
{ return c.text, nil }

ValuesToken
	= "VALUES"i !NormalIdentifierRest
{ return c.text, nil }

CreateToken
	= "CREATE"i !NormalIdentifierRest
{ return c.text, nil }

TableToken
	= "TABLE"i !NormalIdentifierRest
{ return c.text, nil }

IndexToken
	= "INDEX"i !NormalIdentifierRest
{ return c.text, nil }

UniqueToken
	= "UNIQUE"i !NormalIdentifierRest
{ return c.text, nil }

DefaultToken
	= "DEFAULT"i !NormalIdentifierRest
{ return c.text, nil }

PrimaryToken
	= "PRIMARY"i !NormalIdentifierRest
{ return c.text, nil }

KeyToken
	= "KEY"i !NormalIdentifierRest
{ return c.text, nil }

ReferencesToken
	= "REFERENCES"i !NormalIdentifierRest
{ return c.text, nil }

AutoincrementToken
	= "AUTOINCREMENT"i !NormalIdentifierRest
{ return c.text, nil }

OnToken
	= "ON"i !NormalIdentifierRest
{ return c.text, nil }

TrueToken
	= "TRUE"i !NormalIdentifierRest
{ return c.text, nil }

FalseToken
	= "FALSE"i !NormalIdentifierRest
{ return c.text, nil }

NullToken
	= "NULL"i !NormalIdentifierRest
{ return c.text, nil }

IsToken
	= "IS"i !NormalIdentifierRest
{ return c.text, nil }

NullsToken
	= "NULLS"i !NormalIdentifierRest
{ return c.text, nil }

LastToken
	= "LAST"i !NormalIdentifierRest
{ return c.text, nil }

FirstToken
	= "FIRST"i !NormalIdentifierRest
{ return c.text, nil }

AndToken
	= "AND"i !NormalIdentifierRest
{ return c.text, nil }

OrToken
	= "OR"i !NormalIdentifierRest
{ return c.text, nil }

NotToken
	= "NOT"i !NormalIdentifierRest
{ return c.text, nil }

InToken
	= "IN"i !NormalIdentifierRest
{ return c.text, nil }

LikeToken
	= "LIKE"i !NormalIdentifierRest
{ return c.text, nil }

EscapeToken
	= "ESCAPE"i !NormalIdentifierRest
{ return c.text, nil }

AscToken
	= "ASC"i !NormalIdentifierRest
{ return c.text, nil }

DescToken
	= "DESC"i !NormalIdentifierRest
{ return c.text, nil }

CastToken
	= "CAST"i !NormalIdentifierRest
{ return c.text, nil }

AsToken
	= "AS"i !NormalIdentifierRest
{ return c.text, nil }

SeparatorToken
	= ","

AnyToken
	= "*"

/* Identifiers */
Identifier
	= NormalIdentifier
	/ StringIdentifier

NormalIdentifier
	= NormalIdentifierStart NormalIdentifierRest*
{
	node := &ast.IdentifierNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	node.Name = decodeString(c.text)
	return node, nil
}

NormalIdentifierStart
	= [a-zA-Z\x80-\xff]

NormalIdentifierRest
	= [a-zA-Z0-9_\x80-\xff]

StringIdentifier
	= "\"" s:( ( [^"\r\n\\] / "\\" . ) { return c.text, nil } )* "\""
{
	node := &ast.IdentifierNode{}
	node.SetPosition(uint32(c.pos.offset))
	node.SetLength(uint32(len(c.text)))
	bs := joinBytes(assertSlice(s))
	name, bad, code := resolveString(bs)
	if code != se.ErrorCodeNil {
		msg := fmt.Sprintf("cannot resolve escape sequence '%s': %v",
			sanitizeBadEscape(bad), code)
		err := se.Error{
			Position: uint32(c.pos.offset),
			Length:   uint32(len(c.text)),
			Category: se.ErrorCategoryGrammar,
			Code:     code,
			Severity: se.ErrorSeverityError,
			Prefix:   "StringIdentifier",
			Message:  msg,
		}
		return node, err
	}
	node.Name = name
	return node, nil
}

/* Skip */
_
	= Whitespace*
{ return c.text, nil }

Whitespace
	= "\t" // \x09 (HT)
	/ "\n" // \x0a (LF)
	/ "\v" // \x0b (VT)
	/ "\f" // \x0c (FF)
	/ "\r" // \x0d (CR)
	/ " "  // \x20 (SPACE)

EOF
	= !.
